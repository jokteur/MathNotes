#include "block.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui_internal.h"
#include "rich_text/chars/im_char.h"

#include "profiling.h"

namespace RichText {
    bool AbstractBlock::hk_build_delimiter_chars() {
        return true;
    }
    bool AbstractBlock::hk_draw_main(Draw::DrawList& draw_list, float& cursor_y_pos, float x_offset, const Rect& boundaries) {
        //ZoneScoped;
        bool ret = true;
        // At this point, margins have already been taken into account
        ImVec2 padding_before(m_style.h_paddings.x, m_style.v_paddings.x);

        // Update cursor from wrapper
        cursor_y_pos += m_style.v_paddings.x;
        x_offset += m_style.h_paddings.x;

        // Draw all childrens (blocks)
        for (auto ptr : m_childrens) {
            if (ptr->m_category == C_BLOCK)
                if (!ptr->draw(draw_list, cursor_y_pos, x_offset, boundaries))
                    ret = false;
        }
        /* Build widget must be called after drawing the children, because we need to know
         * the positions of the first chars in line in childrens before displaying
         * the delimiters */
        hk_build_widget(x_offset);

        // Draw all the chars generated by the block
        if (isInsideRectY(m_position.y, boundaries)) {
            for (auto ptr : m_draw_chars) {
                if (!ptr->draw(draw_list, boundaries, m_position + padding_before))
                    ret = false;
            }
        }
        cursor_y_pos += m_style.v_paddings.y;

        return ret;
    }
    void AbstractBlock::hk_draw_background(Draw::DrawList& draw_list) {
        if (m_style.bg_color != Colors::transparent) {
            draw_list.SetCurrentChannel(0);
            auto cursor_pos = ImGui::GetCursorScreenPos();
            ImVec2 p_min = cursor_pos + m_position;
            ImVec2 p_max = cursor_pos + m_position + m_dimensions;
            draw_list->AddRectFilled(p_min, p_max, m_style.bg_color, 5.f);
        }
    }
    bool AbstractBlock::hk_build_widget(float x_offset) {
        //ZoneScoped;
        if (m_widget_dirty) {
            m_widget_dirty = 0;
        }
        return true;
    }
    bool AbstractBlock::hk_build_widget_post(float x_offset) {
        //ZoneScoped;
        if (m_widget_dirty && m_is_selected) {
        }
        return true;
    }
    void AbstractBlock::hk_debug_attributes() {
        AbstractElement::hk_debug_attributes();
    }

    bool AbstractLeafBlock::hk_draw_main(Draw::DrawList& draw_list, float& cursor_y_pos, float x_offset, const Rect& boundaries) {
        //ZoneScoped;
        bool ret = true;
        ImVec2 padding_before(m_style.h_paddings.x, m_style.v_paddings.x);

        cursor_y_pos += m_style.v_paddings.x;
        x_offset += m_style.h_paddings.x;

        hk_build_widget(x_offset);

        // Draw all the chars generated by the block
        for (auto ptr : m_draw_chars) {
            if (!ptr->draw(draw_list, boundaries, m_position + padding_before))
                ret = false;
        }
        // Draw all childrens (spans)
        for (auto ptr : m_childrens) {
            if (ptr->m_category != C_SPAN) {
                break;
            }
            if (!ptr->draw(draw_list, cursor_y_pos, x_offset, boundaries))
                ret = false;
        }

        // Update cursor from wrapper
        cursor_y_pos += m_wrapper.getHeight();
        // Draw all childrens (blocks)
        for (auto ptr : m_childrens) {
            if (ptr->m_category == C_BLOCK)
                if (!ptr->draw(draw_list, cursor_y_pos, x_offset, boundaries))
                    ret = false;
        }
        cursor_y_pos += m_style.v_paddings.y;
        return ret;
    }

    bool AbstractLeafBlock::hk_build_widget(float x_offset) {
        //ZoneScoped;
        if (m_widget_dirty) {
            if (m_widget_dirty & DIRTY_CHARS) {
                m_wrap_chars.clear();
                m_draw_chars.clear();

                bool success = true;
                for (auto ptr : m_childrens) {
                    if (ptr->m_category != C_SPAN) {
                        break;
                    }
                    auto res = ptr->add_chars(m_wrap_chars);
                    if (!res) {
                        success = false;
                    }
                }
                if (success)
                    m_widget_dirty ^= DIRTY_CHARS;

                m_wrapper.clear();
                m_wrapper.setLineSpace(m_style.line_space, false);
                m_wrapper.setString(m_wrap_chars, false);
            }
            if (m_widget_dirty & DIRTY_WIDTH) {
                /* Save x offset for later uses (in setWindowWidth) */
                m_x_offset = x_offset;
                float internal_size = m_window_width - x_offset - m_style.h_paddings.y;
                m_wrapper.setWidth(internal_size, false);
                m_widget_dirty ^= DIRTY_WIDTH;
            }
            m_wrapper.recalculate();
        }
        return m_widget_dirty;
    }

    /* ===========
     * HiddenSpace
     * =========== */
    bool HiddenSpace::hk_build_widget(float x_offset) {
        //ZoneScoped;
        if (m_widget_dirty) {
            m_wrap_chars.clear();
            m_draw_chars.clear();

            bool success = true;

            success = add_chars(m_wrap_chars);

            m_wrapper.clear();
            float internal_size = m_window_width - x_offset - m_style.h_paddings.y;
            m_wrapper.setWidth(internal_size);
            m_wrapper.setLineSpace(m_style.line_space);
            m_wrapper.setString(m_wrap_chars);

            if (success)
                m_widget_dirty = false;
        }
        return m_widget_dirty;
    }
    bool HiddenSpace::add_chars(std::vector<WrapCharPtr>& wrap_chars) {
        //ZoneScoped;
        bool success = true;
        m_draw_chars.clear();
        m_is_selected = true;

        if (m_is_selected) {
            auto& bounds = m_text_boundaries.front();
            auto res = Utf8StrToImCharStr(m_ui_state, wrap_chars, m_draw_chars, m_safe_string, bounds.pre, bounds.end, m_special_chars_style, true);
            if (!res) {
                success = false;
            }
        }
        return success;
    }
}